#include "config.hpp"

config MainContext;

/*  config Constructors  */

config::config( std::string const& fileName) 
{
    setPath(fileName);
}

bool config::successful( void )
{
    try {
        parseServersData();
    }
    catch (bool) {
        return false;
    }
    return true;
}

void config::setPath( std::string const& fileName )  
{
    CHECK_CONF_EXTENSION(fileName);
    _configFile.close();
	_configFile.open(fileName, ios::in);
	if (!_configFile.good()) {
		cerr << NAME ": [emerg] " << strerror(errno) << endl;
        exit(EXIT_FAILURE);
    }
	_configFileName = fileName;
}

config::~config(void) 
{
    _configFile.close();
}

/*  config Getters */
std::vector<server_data> config::getServers(void) const
{
    return _servers;
}

/*  config Parsers  */
void config::parseServersData()
{
    std::string                 line;
    std::string                 trimmedLine;
    std::vector<std::string>    tokens;
    bool                        serverEnded = false;
    bool                        isDefaultParsedBefore = false;
    short                       lineNumber = 0;
    /*  Opening The File    */
    // std::ifstream _configFile(_configFileName.c_str());
    // _isFileOpenedAndNotEmpty(_configFile);

    for (; getline(_configFile, line); lineNumber++)
    {
        if (!_isFileGoodToGo(line, lineNumber))
            break;
        trimmedLine = _removeExtraSpaces(line);
        if (_isLineEmptyOrComment(trimmedLine))
            continue;
        /*  When a Line Contain a Server    */
        if (!trimmedLine.empty() && trimmedLine == "server")
        {
            /*  Server object Init */
            server_data currentConfig;

            serverEnded = false;
            getline(_configFile, line);
            if (!_isFileGoodToGo(line, lineNumber))
                break;
            if (_removeExtraSpaces(line) != "{")
                _errorAndExit(SERVERSYNTAXERROR, lineNumber);
            for (;getline(_configFile, line);lineNumber++)
            {
                /*  Starting To Read inside the server Here  */
                if (!_isFileGoodToGo(line, lineNumber))
                    _errorAndExit(READINSERVERGERROR, lineNumber);
                trimmedLine = _removeExtraSpaces(line);
                if (_isLineEmptyOrComment(trimmedLine))
                    continue;
                /*  PARSING DIRECTIVES */
                tokens = _tokenizerOfDirectives(trimmedLine, lineNumber);
                if (line.find("location") != std::string::npos)
                {
                    if (tokens[0] != "location")
                        _errorAndExit(LOCATIONNOTFOUNDERROR, lineNumber);
                    if (tokens.size() != 3)
                        _errorAndExit("Location Must An Argument Path", lineNumber);
                    if (tokens.back() != "{")
                        _errorAndExit(LOCATIONSYNTAXERROR, lineNumber);
                    /*  Init Location Object Here */
                    location_data currentLocationConfig(tokens[1]);
                    for (;getline(_configFile, line);lineNumber++)
                    {
                        if (!_isFileGoodToGo(line, lineNumber))
                            _errorAndExit(READINLOCATIONERROR, lineNumber);
                        trimmedLine = _removeExtraSpaces(line);
                        if (_isLineEmptyOrComment(trimmedLine))
                            continue;
                        if (trimmedLine == "}")
                        {
                            if (currentLocationConfig.isEmpty())
                                _errorAndExit("Parsing the Location!", lineNumber);
                            if (!currentLocationConfig.isLocationValidAndReady())
                                _errorAndExit("Location Inside A Server Must Contain At Least: DefaultPath, Root, index, and At least 1 AllowedMethod", lineNumber);
                            currentConfig.addLocation(currentLocationConfig);
                            break;
                        }
                        _parseLocationDirectives(trimmedLine, currentLocationConfig, lineNumber);
                    }
                    continue;
                }
                else if (tokens[0] == "host" && currentConfig.getHost().empty())
                {
                    if (tokens.size() != 2)
                        _errorAndExit("'Host' directive must have a single Argument.", lineNumber);
                    currentConfig.setHost(_parseHost(tokens[1], lineNumber));
                }
                else if (tokens[0] == "port" && !currentConfig.getListenPort())
                {
                    if (tokens.size() != 2)
                        _errorAndExit("'Port' directive must have a single Argument.", lineNumber);
                    currentConfig.setListenPort(_parsePort(tokens[1], lineNumber));
                }
                else if (tokens[0] == "server_name" && currentConfig.getServerName().empty())
                {
                    if (tokens.size() != 2)
                        _errorAndExit("'server_name' directive must have a single argument.", lineNumber);
                    currentConfig.setServerName(tokens[1]);
                }
                else if (tokens[0] == "default_server" && !isDefaultParsedBefore)
                {
                    // must have a booleen
                    if (tokens.size() != 2)
                        _errorAndExit("'default_server' directive must have a single argument: on or off", lineNumber);
                    if (tokens[1] == "on")
                        currentConfig.setDefaultServer(true);
                    else if (tokens[1] == "off")
                        currentConfig.setDefaultServer(false);
                    else
                        _errorAndExit("cannot recognize the 'default_server' directive Arguments try {on || off}.", lineNumber);
                    isDefaultParsedBefore = true;
                }
                else if (tokens[0] == "error_page")
                {
                    if (tokens.size() != 3)
                        _errorAndExit("'error_page' directive must have two argument: errorNumber and errorPage", lineNumber);
                    currentConfig.addErrorPage(_stringToInt(tokens[1], lineNumber), tokens[2]);
                }
                else if (tokens[0] == "client_max_body_size" && !currentConfig.getMaxBodySize())
                {
                    if (tokens.size() != 2)
                        _errorAndExit("'client_max_body_size' directive must have One argument: Size In Mb", lineNumber);
                    std::string sizeArgument = tokens[1];
                    if (sizeArgument[sizeArgument.size() - 1] != 'M')
                        _errorAndExit("Invalid format for 'client_max_body_size' directive. It should end with 'M'", lineNumber);
                    tokens[1].erase(tokens[1].size() - 1);
                    int tmpSize = _stringToInt(tokens[1], lineNumber);
                    unsigned int maxSizeInBytes = tmpSize * 1024 * 1024;
                    currentConfig.setMaxBodySize(maxSizeInBytes);
                }
                else if (tokens[0] == "}")
                {
                    if (!currentConfig.isServerValidAndReady())
                        _errorAndExit("Server Must Contain At Least: DefaultPath, Root, Index and At least 1 AllowedMethod",lineNumber);
                    _servers.push_back(currentConfig);
                    serverEnded = true;
                    isDefaultParsedBefore = false;
                    break;
                }
                else
                    _errorAndExit(SECTIONSYNTAXERROR, lineNumber);
            }
            if (!serverEnded)
                _errorAndExit(SERVERBRACEERROR, lineNumber);
        }
        else
            _errorAndExit(FILEWITHOUTSERVER, lineNumber);
    }
    if (_servers.size() < 1)
        _errorAndExit(SERVERNOTFOUNDERROR, lineNumber);
}

void config::_parseLocationDirectives(std::string &trimmedLine, location_data &currentLocationConfig, short lineNumber)
{
    std::vector<std::string> tokens = _tokenizerOfDirectives(trimmedLine, lineNumber);

    if (tokens.empty())
        _errorAndExit("Cannote Parse Location Directives 'Empty Directive'", lineNumber);
    if (tokens[0] == "root" && currentLocationConfig.getRoot().empty())
    {
        if (tokens.size() != 2)
            _errorAndExit("'root' directive must have a single argument.", lineNumber);
        currentLocationConfig.setRoot(tokens[1]);
    }
    else if (tokens[0] == "index" && !currentLocationConfig.getIndexes().size())
    {
        if (tokens.size() < 2)
            _errorAndExit("'index' directive must have arguments", lineNumber);
        for (size_t i = 1; i < tokens.size(); i++)
            currentLocationConfig.setIndex(tokens[i]);
    }
    else if (tokens[0] == "auto_index")
    {
        if (tokens.size() != 2)
            _errorAndExit("'auto_index' directive must have a single argument: on or off", lineNumber);
        if (tokens[1] == "on")
            currentLocationConfig.setAutoIndex(true);
        else if (tokens[1] == "off")
            currentLocationConfig.setAutoIndex(false);
        else
            _errorAndExit("cannot recognize the 'autoindex' directive Arguments try {on || off}.", lineNumber);
    }
    else if (tokens[0] == "auto_upload")
    {
        if (tokens.size() != 2)
            _errorAndExit("'auto_upload' directive must have a single argument: on or off", lineNumber);
        if (tokens[1] == "on")
            currentLocationConfig.setAutoUpload(true);
        else if (tokens[1] == "off")
            currentLocationConfig.setAutoUpload(false);
        else
            _errorAndExit("cannot recognize the 'auto_upload' directive Arguments try {on || off}.", lineNumber);
    }
    else if (tokens[0] == "upload_path" && currentLocationConfig.getUploadPath().empty())
    {
        if (tokens.size() != 2)
            _errorAndExit("'upload_path' directive must have a single argument: path", lineNumber);
        currentLocationConfig.setUploadPath(tokens[1]);
    }
    else if (tokens[0] == "cgi_path" && currentLocationConfig.getCgiPath().empty())
    {
        if (tokens.size() != 2)
            _errorAndExit("'cgi_path' directive must have a single argument: path", lineNumber);
        currentLocationConfig.setCgiPath(tokens[1]);
    }
    else if (tokens[0] == "allowed_methods" && !currentLocationConfig.getAllowedMethods().size())
    {
        if (tokens.size() > 4)
            _errorAndExit("'allowed_methods' directive must have Three Methonds Only", lineNumber);
        else if (tokens.size() < 2)
            _errorAndExit("'allowed_methods' directive must have at least One Methond", lineNumber);
        /* Parsing it */
        if (!_parseAllowedMethods(tokens))
            _errorAndExit("Invalid Method keyword", lineNumber);
        for (size_t i = 1; i < tokens.size(); i++)
            currentLocationConfig.setAllowedMethod(tokens[i]);
    }
    else
        _errorAndExit("Duplicate Or Unkown Type Of Directive inside Location", lineNumber);
}

/* ---------- Parsing Helper Functions ----------- */
//  Check if Line Empty Or Comment
bool config::_isLineEmptyOrComment(std::string const &line)
{
    if (line.empty() || line[0] == '#' || line[0] == '\n')
        return true;
    return false;
}
//  Convert String To Int

int config::_stringToInt( std::string const& input, short lineNumber)
{
    std::istringstream iss(input);
    long value;

    iss >> value;

    if (iss.fail() || !iss.eof())
        _errorAndExit("Int: Invalid characters", lineNumber);
    if (value > std::numeric_limits<int>::max() || value < std::numeric_limits<int>::min())
        _errorAndExit("int: Overflow/Underflow during conversion of an Int", lineNumber);
    int result = static_cast<int>(value);
    return result;
}
//  Check For Multiple Semicolone

void config::_splitBySemicolon( std::string const& line, short lineNumber)
{
    int semicoloneCount = 0;

    if (!line.empty())
    {
        for (size_t i = 0; i < line.size(); i++)
        {
            if (line[i] == ';')
                semicoloneCount++;
        }
    }
    if (semicoloneCount > 1)
        _errorAndExit("Duplicate Semicolons in a Directive Line.", lineNumber);
}
//  Iterate and remove Extra Spaces from a line 

std::string config::_removeExtraSpaces( std::string const& line)
{
    std::string result;
    bool spaceFound = false;

    if (line.empty())
        return line;
    for (size_t i = 0; i < line.length(); ++i)
    {
        if (line[i] == ' ' || line[i] == '\t')
            spaceFound = true;
        else
        {
            if (spaceFound)
            {
                result += ' ';
                spaceFound = false;
            }
            result += line[i];
        }
    }

    if (result.empty())
        return result;
    result = result.substr(result.find_first_not_of(" "));
    result = result.substr(0, result.find_last_not_of(" ") + 1);

    return result;
}
// Tokrnize A line and give a meaning to every token (Also Check for Some Errors)

std::vector<std::string> config::_tokenizerOfDirectives(std::string const &line, short lineNumber)
{
    std::istringstream iss(line);
    std::vector<std::string> tokens;
    std::string token;

    /*  Check if Line have multiple semicolone */
    _splitBySemicolon(line, lineNumber);

    /*  {} Braces Line check if Stands Alone at a line */
    if (!line.empty() && line.find("{") != std::string::npos && (line.find("{") + 1) < line.length())
        _errorAndExit("A '{' Brace Must Not Be Followed By Anything !", lineNumber);
    /*  Check if There is Something with }  in the same line */
    if (!line.empty() && line.find("}") != std::string::npos && (line.find("}") + 1) < line.length())
        _errorAndExit("A '}' Brace Must Not Be Followed By Anything !", lineNumber);

    while (iss >> token)
        tokens.push_back(token);
    if (tokens.empty())
        _errorAndExit(SECTIONSYNTAXERROR, lineNumber);

    /*  Check If Directive Ends With a Semicolone */
    if (!line.empty() && (tokens[0] != "location" && tokens[0] != "}" && tokens[0] != "{" && tokens[0] != "server") && line[line.length() - 1] != ';')
        _errorAndExit("A Directive Must End with A semicolone", lineNumber);

    /* Remove the Semicolone from the last Token To Make The Line ready*/
    if (!tokens[tokens.size() - 1].empty() && line[line.length() - 1] == ';')
        tokens[tokens.size() - 1].erase(tokens[tokens.size() - 1].size() - 1);
    return tokens;
}
// Check The Host Errors 

std::string config::_parseHost(std::string const &line, short &lineNumber)
{
    std::istringstream iss(line);
    std::vector<std::string> parts;
    std::string token;

    for (; getline(iss, token, '.'); lineNumber++)
    {
        if (token.find_first_not_of("0123456789") == std::string::npos)
        {
            int num = _stringToInt(token, lineNumber);
            if (num >= 0 && num <= 255)
                parts.push_back(token);
            else
                _errorAndExit("Host Name Out Of Range Error", lineNumber);
        }
        else
            _errorAndExit("Invalid Digits in The Host Value", lineNumber);
    }
    if (parts.size() != 4)
        _errorAndExit("A host Must Have 4 parts", lineNumber);
    return line;
}
// Checking The Port Value Errors  

int config::_parsePort(std::string const &line, short lineNumber)
{
    std::istringstream iss(line);
    long value;

    iss >> value;

    if (iss.fail() || !iss.eof())
        _errorAndExit("Invalid characters in Port Value", lineNumber);
    if (value < 1 || value > 65535)
        _errorAndExit("Out Of Range Port Value", lineNumber);
    int result = static_cast<int>(value);
    return result;
}
// Check The Alloed Methods in a Location

bool config::_parseAllowedMethods(std::vector<std::string> &tokens)
{
    if (!tokens.size())
        return false;

    std::set<std::string> knownAllowedMethods;
    bool valid = false;

    knownAllowedMethods.insert("GET");
    knownAllowedMethods.insert("POST");
    knownAllowedMethods.insert("DELETE");

    for (size_t i = 1; i < tokens.size(); i++)
    {
        if (knownAllowedMethods.find(tokens[i]) != knownAllowedMethods.end())
        {
            knownAllowedMethods.erase(tokens[i]);
            valid = true;
        }
        else
        {
            valid = false;
            break;
        }
    }
    if (!valid || knownAllowedMethods.size() == 3)
        return false;
    return true;
}


bool config::_isFileGoodToGo(std::string const &line, short lineNumber)
{
    if (_configFile.fail())
        _errorAndExit(READINGERROR, lineNumber);
    if (line.empty() && _configFile.eof())
        return false;
    return true;
}

/*  ------- Error printer and exit handler ------- */
void config::_errorAndExit(std::string const &error, short lineNumber)
{
    cerr << NAME ": [emerg] " + error + " in " + _configFileName + ":" << to_string(lineNumber) << endl;
    throw false;
}

/*  Display Current Servers Data    */
void    config::disp() const
{
    string configFile;
    _configFile.clear();
    _configFile.seekg(0, std::ios::beg);
    getline(_configFile, configFile, (char)0);
    cerr << configFile;
}# include "optioneer.hpp"

OptionFunction optionFunctions[] = {
        &Options::showHelp,
        &Options::version,
        &Options::setErrorLogFile,
        &Options::setConfigFile,
        &Options::testConfig,
        &Options::testConfigAndDump,
        &Options::showVersionAndConfig,
};

Options::Options(int argc, char *const argv[]) : p_conf(""), p_error(""), is_successful(false) {
    options(argc, argv);
}

void Options::options(int argc, char *const argv[])
{
    t_options   option, flag;
    string      option_name(": invalid option: ");

    option = flag = opterr = false;

    for (; option != GETOPT_EXIT; option = getopt(argc, argv, Sx_options)) 
    {   
        flag |= (option == 'h') * HELP;
        flag |= (option == 'v') * VERSION;
        flag |= (option == 'e') * ERROR_LOG;
        flag |= (option == 't') * TEST_CONFIG;
        flag |= (option == 'c') * CONFIG_FILE;
        flag |= (option == 'T') * TEST_CONFIG_DUMP;
        flag |= (option == 'V') * SHOW_VERSION_CONFIG;
        flag  = (option == '?') ? UNKNOWN : flag;
        if ( flag & UNKNOWN )
            goto something_else;        
        p_conf = p_error = ( flag & (CONFIG_FILE | ERROR_LOG) ) ? string(optarg) : "";
    }

    if (option ^ EPERM and !flag) 
        return (void)(is_successful = true);

    something_else:

        if (flag & ~( HELP | VERSION | ERROR_LOG | TEST_CONFIG | TEST_CONFIG_DUMP | SHOW_VERSION_CONFIG | CONFIG_FILE ))
        {
            option_name.push_back(optopt);
            cout << NAME << ( (optopt == 'e' or optopt == 'c') ? string(": option \"-") + string(1, optopt) + string("\" requires file name") : option_name) << endl;
        }
        else if ( flag & ~UNKNOWN ) 
            (*this.*optionFunctions[ (int)log2(flag) - 1]) ();
    is_successful = (flag & CONFIG_FILE);
}

/*
    i will handel logs in my serveX ;
*/

void Options::setErrorLogFile() const 
{
    struct stat _st;
    memset(&_st, 0, sizeof _st);
    errno = stat(p_error.c_str(), &_st) != 0 ? ENOENT : S_ISDIR(_st.st_mode) ? EISDIR : 0;

    if ( errno & (ENOENT | EISDIR) )
		cerr << NAME ": \"" << p_error << "\" failed : " << strerror(errno) << endl, is_successful = false;
    // set p_error
}

void Options::setConfigFile() const 
{
    struct stat _st;
    memset(&_st, 0, sizeof _st);
    errno = stat(p_error.c_str(), &_st) != 0 ? ENOENT : S_ISDIR(_st.st_mode) ? EISDIR : 0;

    if ( errno & (ENOENT | EISDIR) )
		cerr << NAME ": \"" << p_conf << "\" failed : " << strerror(errno) << endl, is_successful = false;
    
    MainContext.setPath(p_conf);
}

void Options::testConfigAndDump() const 
{  
    testConfig();
    if (is_successful)
        MainContext.disp();
}

void Options::testConfig() const 
{
    is_successful = MainContext.successful();
    if (is_successful)
        cerr << NAME ": the configuration file " << MainContext._configFileName << " syntax is ok" << endl;
	cerr << NAME ": configuration file \"" << MainContext._configFileName << "\" test is " << (is_successful ? "successful" : "failed") << endl;
}

void Options::version() const {
    cout << (NAME " version:" NAME "/" _VERSION) << endl;
}

void Options::showHelp( void ) const {
    cout << (NAME "/" _VERSION) << endl;
    cout << HELP_OPTIONS << endl;
}

void Options::showVersionAndConfig() const {
    version();
    cout << "built with OpenSSL 3.0.5 5 Jul 2022 (running with OpenSSL 3.0.10 1 Aug 2023)"
            "TLS SNI support enabled" << endl;
}

bool Options::successful( void ) const { return is_successful; }
# include "server.hpp"
# include "../www/socket.hpp"
# include "../utility/utils.hpp"
# include "../www/client.hpp"
#include <cstdio>
#include <sys/select.h>

// Clients clients;

std::vector<s_client> clients;

void init_Webserv(int argc, char *const argv[])
{
    Options opt(argc, argv);

    if (!opt.successful() or !MainContext.successful())
        return ;

    pair<socket_t, socket_t>  fd_range;
    fd_set                    rd_socket, wr_socket, wr_socket_copy, rd_socket_copy;
    vector<Socket>            _socket = init_Socket(MainContext.getServers(), rd_socket, fd_range);
    FD_ZERO(&wr_socket);
    while (true)
    {
        FD_ZERO(&rd_socket_copy);
        FD_ZERO(&wr_socket_copy);
        rd_socket_copy = rd_socket;
        wr_socket_copy = wr_socket;
        // select function wait for any event in the socket
        if (select(fd_range.second + 1, &(rd_socket_copy), &wr_socket_copy, NULL, 0) == -1)
            perror("select");
    
        for (int i = fd_range.first; i < fd_range.second + 1; i++)
        {
            // FD_ISSET check if the socket is ready to read or write
            if (FD_ISSET(i, &(rd_socket_copy)))
            {   int idx = is_inSocket(i, _socket);
                if (idx != -1)
                {
                    socket_t newconnection = _socket[idx].accept();
                    if (newconnection == -1)
                    {
                        cerr << NAME << " : Failed to accept connection." << endl;
                        goto ExpireConnection;
                    }
                    clients[clients.size() - 1].set_server_idx(idx, i);
                    FD_SET(newconnection, &(rd_socket));
                    if (newconnection > fd_range.second)
                        fd_range.second = newconnection;
                }
                else
                {
                    for (int c = 0; c < clients.size(); c++) {
                        if (clients[c].get_client_socket() == i) {
                            clients[c].DealwithRequest();
                            // yoel-idr use your flag to check if you have done reading the request before this two lines
                            if (clients[c].isReady())
                            {
                                FD_CLR(i, &(rd_socket));
                                FD_SET(i, &wr_socket);

                            }
                            break ;
                        }
                    }
                }
            }
            if (FD_ISSET(i, &wr_socket_copy))
            {
                for (int c = 0; c < clients.size(); c++) {
                    if (clients[c].get_client_socket() == i) {
                        clients[c].DealwithResponce();
                        // yoel-idr use your flag to check if you have done sending the response before this tree lines
                        FD_CLR(i, &wr_socket);
                        std::cout << "client " << c << " will be deleted" << std::endl;
                        clients.erase(clients.begin() + c);
                        close(i);
                        break ;
                    }
                }
            }
            ExpireConnection:
                clients[0].Expireconnection(); // to handel 
        }
    }
}